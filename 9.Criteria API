Criteria
	CriteriaBuilder: from EntityManager, creates CriteriaQuery and contains matching methods like .equal(x, y)
	CriteriaQuery: from CriteriaBuilder, represents the query, creates Root object. Contains methods with query clauses like .select(). .where() and so on
	Root: from CriteriaQuery, represents main identification variable of the query (SELECT e FROM Employee e), has .get(field) method to traverse the relationship
	Join: from Root by calling .join(field, JoinType.SOMETHING). Like root is an ID variable with .get(field) method 
	ParameterExpression: from CriteriaBuilder, represents the parameter to the query. cb.parameter(String.class, "name")
	Predicate: from CriteriaBuilder by calling .equal(x, y) or others. Is passed to .where() method to filter the results
Select
	CriteriaBuilder has .createQuery(Class<T> c) for typed result, .createQuery() forObject result and .createTupleQuery() for report queries with several return values
	CriteriaQuery is not related to Query interface, it's just a query definition
	Invoking .select() or .where() twice on CriteriaQuery overwrites the content, invoking .from() several times results in several query roots(and therefore a Cartesian product)
	Traversing the path is possible with multiple gets(emp.phone.number == .from(Employee.class).get("phone").get("number"))
	It's possible to pass generic call to .get() to .select() method, to query for a field: c.select(emp.<String>get("name")) -- generic here is for type inference
	For compound selection, pass cb.tuple(emp.get(name), ...)
	Alternative: c.multiselect(...) when the query is created with Object[].class or some special class with defined constructor(for constructor expression)
	Constructor expression can also be created by passing cb.construct(Report.class, params...) to select method
	When slecting a Tuple, it's possible to call .alias("someName") on .get() to later access the value in the Tuple object by this alias
Joins
	When joining on collections, the result is Join<Parent, TypeInCollection>, with maps: .joinMap() and the resutl is MapJoin<Parent, KeyType, ValueType>
	Joins are additive, each call resutns new ID variable
	For fetch-join use root.fetch(field, joinType)
	JoinType.INNER is the default for both join and fetch
Where
	Predicates, to be passed to .where() are mostly created by CriteriaBuilder
	To build predicates incrementaly, cb.conjunction() for AND or cb.disjunction for OR can be obtained to be passed to cb.and() 
	Literals can be wrapped with .literal(), to obtain null literal use .nullLiteral()

	Subqueries can be created by calling c.subquery(Some.class)
	Method .correlate(root) in the Subquery is like a .from(), but it takesa root object, showing that the same variable should be used in the subquery 
		i.e. (SELECT e FROM Employee e WHERE EXISTS (SELECT P FROM e.projects p WHERE p.name = :name)) becomes => Root<A> root = c.from(A.class); Subquery<B> sq = c.subquery(B.class); Root<A> secondRoot = sq.correlate(root)
	It's also possible to correlate by join by passing the join to .correlate. The result is the similar join object

	Method cb.in(field), unlike with query, takes a single parameter to be matched, all cases have to be passed by chaining .value(option) calls on it
	Alternatively, method .in(vararg) can be called on the root.get(field)
	CASE expression is created by cb.selectCase(), it supports chaining .when(predicate, value) on it with .otherwise() at the end
	If the expression to test was pased to cb.selectCase(dep.get("number")), chain .when(value, result) to match against
	COALESE is created by cb.coalese() with chainged .value(root.get(field)), returns first that is not null. Is overloaded to accept two parameters
	To call native SQL FUNCTION, call cb.function(funName, SomeResult.class, params...)
Other clauses
	ORDER BY is created by c.orderBy(params...), where params == cb.asc(root.get(filed)) / cb.desc(root.get(field))
	Both c.groupBy(root/join) and .having(predicate) are on the CriteriaQuery and are identical to JPQL usage
Metamodel API
	Metamodel is a way to add strong typing to the Criteria API by passing typed fields of generated metamodel instead of String names
	Metamodel object can be obtained by em.getMetamodel() and then call .entity(class)/.embeddable(class)/.managedType(class) => EntityType<class>
	Can also be obtained by root object: root.getModel()
	EntityType<> has getters for Singular/Collection/Set/ListAttribute(name, class) and MapAttribute(name, keyClass, valueClass) to be passed instead of Strings

	Canonical metamodel is a bunch of classes like Entity_.class and @StasicMetamodel(Entity.class) that can be generated in the same package 
	It has all the corresponging Singular/Collection/Set/List/MapAttributes that are public static volatile
	All those fields can be passed to .join(), .get() and so on instead of Strings
	Canonical metamodel is generated by special processor passed to javac with flags "-processor the.path.Processor.class -proc:only" and others
	